import sys
import angr
import claripy
import logging

def main(bin = './Crack'):
    # Create an Angr project.
    project = angr.Project(bin)
    PASS_LEN=128
    START_ADDR = 0x080485fa
    arg1 = claripy.BVS('arg1', PASS_LEN*8)

    # Create a symbolic bitvector representing the parameters from the command line
    initial_state = project.factory.blank_state(addr=START_ADDR, add_options={angr.options.LAZY_SOLVES})
    VAR_ADDR= initial_state.regs.esp - 0x100
    print(f"VAR ADDR {VAR_ADDR}")
    # Restrict to printable chars
    for byte in arg1.chop(8):
        initial_state.add_constraints(byte != '\x00') # null
        initial_state.add_constraints(byte >= ' ') # '\x20'
        initial_state.add_constraints(byte <= '~') # '\x7e'

    initial_state.memory.store(VAR_ADDR, arg1)

    # Create a simulation manager initialized with the starting state. It provides
    # a number of useful tools to search and execute the binary.
    simulation = project.factory.simgr(initial_state)

    # If the state that prints this message is found, then we have found the correct simulation
    def is_successful(state):
        stdout_output = state.posix.dumps(sys.stdout.fileno())
        if b'Good work' in stdout_output:
            return True
        else:
            return False
    # If the state that prints this message is found, then we have found the correct simulation
    def bad_path(state):
        stdout_output = state.posix.dumps(sys.stdout.fileno())
        if b' !' in stdout_output:
            return True
        else:
            return False
    # Explore simulations until the message is found
    simulation.explore(find=is_successful, avoid=bad_path)

    # Check that we have found a solution. The simulation.explore() method will
    # set simulation.found to a list of the states that it could find that reach
    # the instruction we asked it to search for. Remember, in Python, if a list
    # is empty, it will be evaluated as false, otherwise true.
    if simulation.found:
        # Just take the first found solution
        solution_state = simulation.found[0]

        # Print the string that Angr wrote to stdin; this is our solution.
        print(solution_state.posix.dumps(sys.stdout.fileno()))
        solution0 = (solution_state.solver.eval(arg1, cast_to=bytes))
        print(solution0)

    else:
        # If Angr could not find a path that reaches print_good_address, throw an
        # error. Perhaps you mistyped the print_good_address?
        raise Exception('Could not find the solution')


if __name__ == '__main__':
    main()
